--- drivers/gpu/drm/rockchip/rockchip_lvds.c
+++ drivers/gpu/drm/rockchip/rockchip_lvds.c
@@ -166,500 +210,235 @@ struct drm_connector_helper_funcs rockchip_lvds_connector_helper_funcs = {
 	.get_modes = rockchip_lvds_connector_get_modes,
 };
 
-static int
-rockchip_lvds_encoder_atomic_check(struct drm_encoder *encoder,
-				   struct drm_crtc_state *crtc_state,
-				   struct drm_connector_state *conn_state)
-{
-	struct rockchip_crtc_state *s = to_rockchip_crtc_state(crtc_state);
-
-	s->output_mode = ROCKCHIP_OUT_MODE_P888;
-	s->output_type = DRM_MODE_CONNECTOR_LVDS;
-
-	return 0;
-}
-
-static int rk3288_lvds_poweron(struct rockchip_lvds *lvds)
+static void
+rockchip_lvds_encoder_atomic_mode_set(struct drm_encoder *encoder,
+				      struct drm_crtc_state *crtc_state,
+				      struct drm_connector_state *conn_state)
 {
-	int ret;
-	u32 val;
-
-	ret = clk_enable(lvds->pclk);
-	if (ret < 0) {
-		DRM_DEV_ERROR(lvds->dev, "failed to enable lvds pclk %d\n", ret);
-		return ret;
-	}
-	ret = pm_runtime_get_sync(lvds->dev);
-	if (ret < 0) {
-		DRM_DEV_ERROR(lvds->dev, "failed to get pm runtime: %d\n", ret);
-		clk_disable(lvds->pclk);
-		return ret;
-	}
-	val = RK3288_LVDS_CH0_REG0_LANE4_EN | RK3288_LVDS_CH0_REG0_LANE3_EN |
-		RK3288_LVDS_CH0_REG0_LANE2_EN | RK3288_LVDS_CH0_REG0_LANE1_EN |
-		RK3288_LVDS_CH0_REG0_LANE0_EN;
-	if (lvds->output == DISPLAY_OUTPUT_RGB) {
-		val |= RK3288_LVDS_CH0_REG0_TTL_EN |
-			RK3288_LVDS_CH0_REG0_LANECK_EN;
-		rk3288_writel(lvds, RK3288_LVDS_CH0_REG0, val);
-		rk3288_writel(lvds, RK3288_LVDS_CH0_REG2,
-			      RK3288_LVDS_PLL_FBDIV_REG2(0x46));
-		rk3288_writel(lvds, RK3288_LVDS_CH0_REG4,
-			      RK3288_LVDS_CH0_REG4_LANECK_TTL_MODE |
-			      RK3288_LVDS_CH0_REG4_LANE4_TTL_MODE |
-			      RK3288_LVDS_CH0_REG4_LANE3_TTL_MODE |
-			      RK3288_LVDS_CH0_REG4_LANE2_TTL_MODE |
-			      RK3288_LVDS_CH0_REG4_LANE1_TTL_MODE |
-			      RK3288_LVDS_CH0_REG4_LANE0_TTL_MODE);
-		rk3288_writel(lvds, RK3288_LVDS_CH0_REG5,
-			      RK3288_LVDS_CH0_REG5_LANECK_TTL_DATA |
-			      RK3288_LVDS_CH0_REG5_LANE4_TTL_DATA |
-			      RK3288_LVDS_CH0_REG5_LANE3_TTL_DATA |
-			      RK3288_LVDS_CH0_REG5_LANE2_TTL_DATA |
-			      RK3288_LVDS_CH0_REG5_LANE1_TTL_DATA |
-			      RK3288_LVDS_CH0_REG5_LANE0_TTL_DATA);
-	} else {
-		val |= RK3288_LVDS_CH0_REG0_LVDS_EN |
-			    RK3288_LVDS_CH0_REG0_LANECK_EN;
-		rk3288_writel(lvds, RK3288_LVDS_CH0_REG0, val);
-		rk3288_writel(lvds, RK3288_LVDS_CH0_REG1,
-			      RK3288_LVDS_CH0_REG1_LANECK_BIAS |
-			      RK3288_LVDS_CH0_REG1_LANE4_BIAS |
-			      RK3288_LVDS_CH0_REG1_LANE3_BIAS |
-			      RK3288_LVDS_CH0_REG1_LANE2_BIAS |
-			      RK3288_LVDS_CH0_REG1_LANE1_BIAS |
-			      RK3288_LVDS_CH0_REG1_LANE0_BIAS);
-		rk3288_writel(lvds, RK3288_LVDS_CH0_REG2,
-			      RK3288_LVDS_CH0_REG2_RESERVE_ON |
-			      RK3288_LVDS_CH0_REG2_LANECK_LVDS_MODE |
-			      RK3288_LVDS_CH0_REG2_LANE4_LVDS_MODE |
-			      RK3288_LVDS_CH0_REG2_LANE3_LVDS_MODE |
-			      RK3288_LVDS_CH0_REG2_LANE2_LVDS_MODE |
-			      RK3288_LVDS_CH0_REG2_LANE1_LVDS_MODE |
-			      RK3288_LVDS_CH0_REG2_LANE0_LVDS_MODE |
-			      RK3288_LVDS_PLL_FBDIV_REG2(0x46));
-		rk3288_writel(lvds, RK3288_LVDS_CH0_REG4, 0x00);
-		rk3288_writel(lvds, RK3288_LVDS_CH0_REG5, 0x00);
+	struct rockchip_lvds *lvds = encoder_to_lvds(encoder);
+	struct drm_connector *connector = &lvds->connector;
+	struct drm_display_info *info = &connector->display_info;
+	u32 bus_format = MEDIA_BUS_FMT_RGB888_1X7X4_SPWG;
+
+	if (info->num_bus_formats)
+		bus_format = info->bus_formats[0];
+
+	switch (bus_format) {
+	case MEDIA_BUS_FMT_RGB888_1X7X4_JEIDA:	/* jeida-24 */
+		lvds->format = LVDS_8BIT_MODE_FORMAT_2;
+		break;
+	case MEDIA_BUS_FMT_RGB101010_1X7X5_JEIDA: /* jeida-30 */
+		lvds->format = LVDS_10BIT_MODE_FORMAT_2;
+		break;
+	case MEDIA_BUS_FMT_RGB666_1X7X3_SPWG:	/* vesa-18 */
+		lvds->format = LVDS_8BIT_MODE_FORMAT_3;
+		break;
+	case MEDIA_BUS_FMT_RGB101010_1X7X5_SPWG: /* vesa-30 */
+		lvds->format = LVDS_10BIT_MODE_FORMAT_1;
+		break;
+	case MEDIA_BUS_FMT_RGB888_1X7X4_SPWG:	/* vesa-24 */
+	default:
+		lvds->format = LVDS_8BIT_MODE_FORMAT_1;
+		break;
 	}
-	rk3288_writel(lvds, RK3288_LVDS_CH0_REG3,
-		      RK3288_LVDS_PLL_FBDIV_REG3(0x46));
-	rk3288_writel(lvds, RK3288_LVDS_CH0_REGD,
-		      RK3288_LVDS_PLL_PREDIV_REGD(0x0a));
-	rk3288_writel(lvds, RK3288_LVDS_CH0_REG20,
-		      RK3288_LVDS_CH0_REG20_LSB);
-
-	rk3288_writel(lvds, RK3288_LVDS_CFG_REGC,
-		      RK3288_LVDS_CFG_REGC_PLL_ENABLE);
-	rk3288_writel(lvds, RK3288_LVDS_CFG_REG21,
-		      RK3288_LVDS_CFG_REG21_TX_ENABLE);
-
-	return 0;
-}
 
-static void rk3288_lvds_poweroff(struct rockchip_lvds *lvds)
-{
-	int ret;
-	u32 val;
+	if (lvds->secondary)
+		lvds->secondary->format = lvds->format;
 
-	rk3288_writel(lvds, RK3288_LVDS_CFG_REG21,
-		      RK3288_LVDS_CFG_REG21_TX_ENABLE);
-	rk3288_writel(lvds, RK3288_LVDS_CFG_REGC,
-		      RK3288_LVDS_CFG_REGC_PLL_ENABLE);
-	val = LVDS_DUAL | LVDS_TTL_EN | LVDS_CH0_EN | LVDS_CH1_EN | LVDS_PWRDN;
-	val |= val << 16;
-	ret = regmap_write(lvds->grf, RK3288_LVDS_GRF_SOC_CON7, val);
-	if (ret != 0)
-		DRM_DEV_ERROR(lvds->dev, "Could not write to GRF: %d\n", ret);
-
-	pm_runtime_put(lvds->dev);
-	clk_disable(lvds->pclk);
+	drm_mode_copy(&lvds->mode, &crtc_state->adjusted_mode);
 }
 
-static int rk3288_lvds_grf_config(struct drm_encoder *encoder,
-				  struct drm_display_mode *mode)
+static int
+rockchip_lvds_encoder_atomic_check(struct drm_encoder *encoder,
+				   struct drm_crtc_state *crtc_state,
+				   struct drm_connector_state *conn_state)
 {
+	struct rockchip_crtc_state *s = to_rockchip_crtc_state(crtc_state);
 	struct rockchip_lvds *lvds = encoder_to_lvds(encoder);
-	u8 pin_hsync = (mode->flags & DRM_MODE_FLAG_PHSYNC) ? 1 : 0;
-	u8 pin_dclk = (mode->flags & DRM_MODE_FLAG_PCSYNC) ? 1 : 0;
-	u32 val;
-	int ret;
-
-	/* iomux to LCD data/sync mode */
-	if (lvds->output == DISPLAY_OUTPUT_RGB)
-		if (lvds->pins && !IS_ERR(lvds->pins->default_state))
-			pinctrl_select_state(lvds->pins->p,
-					     lvds->pins->default_state);
-	val = lvds->format | LVDS_CH0_EN;
-	if (lvds->output == DISPLAY_OUTPUT_RGB)
-		val |= LVDS_TTL_EN | LVDS_CH1_EN;
-	else if (lvds->output == DISPLAY_OUTPUT_DUAL_LVDS)
-		val |= LVDS_DUAL | LVDS_CH1_EN;
-
-	if ((mode->htotal - mode->hsync_start) & 0x01)
-		val |= LVDS_START_PHASE_RST_1;
-
-	val |= (pin_dclk << 8) | (pin_hsync << 9);
-	val |= (0xffff << 16);
-	ret = regmap_write(lvds->grf, RK3288_LVDS_GRF_SOC_CON7, val);
-	if (ret)
-		DRM_DEV_ERROR(lvds->dev, "Could not write to GRF: %d\n", ret);
-
-	return ret;
-}
+	struct drm_connector *connector = conn_state->connector;
+	struct drm_display_info *info = &connector->display_info;
 
-static int rk3288_lvds_set_vop_source(struct rockchip_lvds *lvds,
-				      struct drm_encoder *encoder)
-{
-	u32 val;
-	int ret;
+	if (info->num_bus_formats)
+		s->bus_format = info->bus_formats[0];
+	else
+		s->bus_format = MEDIA_BUS_FMT_RGB888_1X7X4_SPWG;
 
-	ret = drm_of_encoder_active_endpoint_id(lvds->dev->of_node, encoder);
-	if (ret < 0)
-		return ret;
+	s->output_mode = ROCKCHIP_OUT_MODE_P888;
 
-	val = RK3288_LVDS_SOC_CON6_SEL_VOP_LIT << 16;
-	if (ret)
-		val |= RK3288_LVDS_SOC_CON6_SEL_VOP_LIT;
+	if (s->bus_format == MEDIA_BUS_FMT_RGB101010_1X7X5_SPWG ||
+	    s->bus_format == MEDIA_BUS_FMT_RGB101010_1X7X5_JEIDA)
+		s->output_mode = ROCKCHIP_OUT_MODE_AAAA;
 
-	ret = regmap_write(lvds->grf, RK3288_LVDS_GRF_SOC_CON6, val);
-	if (ret < 0)
-		return ret;
+	s->output_type = DRM_MODE_CONNECTOR_LVDS;
+	s->bus_flags = info->bus_flags;
+	s->tv_state = &conn_state->tv;
+	s->eotf = HDMI_EOTF_TRADITIONAL_GAMMA_SDR;
+	s->color_space = V4L2_COLORSPACE_DEFAULT;
+
+	switch (lvds->pixel_order) {
+	case DRM_LVDS_DUAL_LINK_ODD_EVEN_PIXELS:
+		s->output_flags |= ROCKCHIP_OUTPUT_DUAL_CHANNEL_ODD_EVEN_MODE;
+		s->output_if |= VOP_OUTPUT_IF_LVDS1 | VOP_OUTPUT_IF_LVDS0;
+		break;
+	case DRM_LVDS_DUAL_LINK_EVEN_ODD_PIXELS:
+		s->output_flags |= ROCKCHIP_OUTPUT_DUAL_CHANNEL_ODD_EVEN_MODE;
+		s->output_flags |= ROCKCHIP_OUTPUT_DATA_SWAP;
+		s->output_if |= VOP_OUTPUT_IF_LVDS1 | VOP_OUTPUT_IF_LVDS0;
+		break;
+/*
+ * Fix me: To do it with a GKI compatible version.
+ */
+#if 0
+	case DRM_LVDS_DUAL_LINK_LEFT_RIGHT_PIXELS:
+		s->output_flags |= ROCKCHIP_OUTPUT_DUAL_CHANNEL_LEFT_RIGHT_MODE;
+		s->output_if |= VOP_OUTPUT_IF_LVDS1 | VOP_OUTPUT_IF_LVDS0;
+		break;
+	case DRM_LVDS_DUAL_LINK_RIGHT_LEFT_PIXELS:
+		s->output_flags |= ROCKCHIP_OUTPUT_DUAL_CHANNEL_LEFT_RIGHT_MODE;
+		s->output_flags |= ROCKCHIP_OUTPUT_DATA_SWAP;
+		s->output_if |= VOP_OUTPUT_IF_LVDS1 | VOP_OUTPUT_IF_LVDS0;
+		break;
+#endif
+	default:
+		if (lvds->id)
+			s->output_if |= VOP_OUTPUT_IF_LVDS1;
+		else
+			s->output_if |= VOP_OUTPUT_IF_LVDS0;
+		break;
+	}
 
 	return 0;
 }
 
-static void rk3288_lvds_encoder_enable(struct drm_encoder *encoder)
+static void rockchip_lvds_enable(struct rockchip_lvds *lvds)
 {
-	struct rockchip_lvds *lvds = encoder_to_lvds(encoder);
-	struct drm_display_mode *mode = &encoder->crtc->state->adjusted_mode;
 	int ret;
 
-	drm_panel_prepare(lvds->panel);
-
-	ret = rk3288_lvds_poweron(lvds);
-	if (ret < 0) {
-		DRM_DEV_ERROR(lvds->dev, "failed to power on LVDS: %d\n", ret);
-		drm_panel_unprepare(lvds->panel);
-		return;
-	}
-
-	ret = rk3288_lvds_grf_config(encoder, mode);
-	if (ret) {
-		DRM_DEV_ERROR(lvds->dev, "failed to configure LVDS: %d\n", ret);
-		drm_panel_unprepare(lvds->panel);
-		return;
-	}
+	if (lvds->funcs->enable)
+		lvds->funcs->enable(lvds);
 
-	ret = rk3288_lvds_set_vop_source(lvds, encoder);
+	ret = phy_set_mode(lvds->phy, PHY_MODE_LVDS);
 	if (ret) {
-		DRM_DEV_ERROR(lvds->dev, "failed to set VOP source: %d\n", ret);
-		drm_panel_unprepare(lvds->panel);
+		DRM_DEV_ERROR(lvds->dev, "failed to set phy mode: %d\n", ret);
 		return;
 	}
 
-	drm_panel_enable(lvds->panel);
-}
-
-static void rk3288_lvds_encoder_disable(struct drm_encoder *encoder)
-{
-	struct rockchip_lvds *lvds = encoder_to_lvds(encoder);
+	phy_power_on(lvds->phy);
 
-	drm_panel_disable(lvds->panel);
-	rk3288_lvds_poweroff(lvds);
-	drm_panel_unprepare(lvds->panel);
+	if (lvds->secondary)
+		rockchip_lvds_enable(lvds->secondary);
 }
 
-static int px30_lvds_poweron(struct rockchip_lvds *lvds)
+static void rockchip_lvds_disable(struct rockchip_lvds *lvds)
 {
-	int ret;
-
-	ret = pm_runtime_get_sync(lvds->dev);
-	if (ret < 0) {
-		DRM_DEV_ERROR(lvds->dev, "failed to get pm runtime: %d\n", ret);
-		return ret;
-	}
-
-	/* Enable LVDS mode */
-	return regmap_update_bits(lvds->grf, PX30_LVDS_GRF_PD_VO_CON1,
-				  PX30_LVDS_MODE_EN(1) | PX30_LVDS_P2S_EN(1),
-				  PX30_LVDS_MODE_EN(1) | PX30_LVDS_P2S_EN(1));
-}
+	if (lvds->funcs->disable)
+		lvds->funcs->disable(lvds);
 
-static void px30_lvds_poweroff(struct rockchip_lvds *lvds)
-{
-	regmap_update_bits(lvds->grf, PX30_LVDS_GRF_PD_VO_CON1,
-			   PX30_LVDS_MODE_EN(1) | PX30_LVDS_P2S_EN(1),
-			   PX30_LVDS_MODE_EN(0) | PX30_LVDS_P2S_EN(0));
+	phy_power_off(lvds->phy);
 
-	pm_runtime_put(lvds->dev);
+	if (lvds->secondary)
+		rockchip_lvds_disable(lvds->secondary);
 }
 
-static int px30_lvds_grf_config(struct drm_encoder *encoder,
-				struct drm_display_mode *mode)
+static void rockchip_lvds_encoder_enable(struct drm_encoder *encoder)
 {
 	struct rockchip_lvds *lvds = encoder_to_lvds(encoder);
 
-	if (lvds->output != DISPLAY_OUTPUT_LVDS) {
-		DRM_DEV_ERROR(lvds->dev, "Unsupported display output %d\n",
-			      lvds->output);
-		return -EINVAL;
-	}
-
-	/* Set format */
-	return regmap_update_bits(lvds->grf, PX30_LVDS_GRF_PD_VO_CON1,
-				  PX30_LVDS_FORMAT(lvds->format),
-				  PX30_LVDS_FORMAT(lvds->format));
-}
-
-static int px30_lvds_set_vop_source(struct rockchip_lvds *lvds,
-				    struct drm_encoder *encoder)
-{
-	int vop;
-
-	vop = drm_of_encoder_active_endpoint_id(lvds->dev->of_node, encoder);
-	if (vop < 0)
-		return vop;
-
-	return regmap_update_bits(lvds->grf, PX30_LVDS_GRF_PD_VO_CON1,
-				  PX30_LVDS_VOP_SEL(1),
-				  PX30_LVDS_VOP_SEL(vop));
+	if (lvds->panel)
+		drm_panel_prepare(lvds->panel);
+	rockchip_lvds_enable(lvds);
+	if (lvds->panel)
+		drm_panel_enable(lvds->panel);
 }
 
-static void px30_lvds_encoder_enable(struct drm_encoder *encoder)
+static void rockchip_lvds_encoder_disable(struct drm_encoder *encoder)
 {
 	struct rockchip_lvds *lvds = encoder_to_lvds(encoder);
-	struct drm_display_mode *mode = &encoder->crtc->state->adjusted_mode;
-	int ret;
-
-	drm_panel_prepare(lvds->panel);
-
-	ret = px30_lvds_poweron(lvds);
-	if (ret) {
-		DRM_DEV_ERROR(lvds->dev, "failed to power on LVDS: %d\n", ret);
-		drm_panel_unprepare(lvds->panel);
-		return;
-	}
-
-	ret = px30_lvds_grf_config(encoder, mode);
-	if (ret) {
-		DRM_DEV_ERROR(lvds->dev, "failed to configure LVDS: %d\n", ret);
-		drm_panel_unprepare(lvds->panel);
-		return;
-	}
 
-	ret = px30_lvds_set_vop_source(lvds, encoder);
-	if (ret) {
-		DRM_DEV_ERROR(lvds->dev, "failed to set VOP source: %d\n", ret);
+	if (lvds->panel)
+		drm_panel_disable(lvds->panel);
+	rockchip_lvds_disable(lvds);
+	if (lvds->panel)
 		drm_panel_unprepare(lvds->panel);
-		return;
-	}
-
-	drm_panel_enable(lvds->panel);
 }
 
-static void px30_lvds_encoder_disable(struct drm_encoder *encoder)
+static void rockchip_lvds_encoder_loader_protect(struct drm_encoder *encoder,
+						 bool on)
 {
 	struct rockchip_lvds *lvds = encoder_to_lvds(encoder);
 
-	drm_panel_disable(lvds->panel);
-	px30_lvds_poweroff(lvds);
-	drm_panel_unprepare(lvds->panel);
+	if (lvds->panel)
+		panel_simple_loader_protect(lvds->panel);
 }
 
 static const
-struct drm_encoder_helper_funcs rk3288_lvds_encoder_helper_funcs = {
-	.enable = rk3288_lvds_encoder_enable,
-	.disable = rk3288_lvds_encoder_disable,
+struct drm_encoder_helper_funcs rockchip_lvds_encoder_helper_funcs = {
+	.enable = rockchip_lvds_encoder_enable,
+	.disable = rockchip_lvds_encoder_disable,
 	.atomic_check = rockchip_lvds_encoder_atomic_check,
+	.atomic_mode_set = rockchip_lvds_encoder_atomic_mode_set,
 };
 
-static const
-struct drm_encoder_helper_funcs px30_lvds_encoder_helper_funcs = {
-	.enable = px30_lvds_encoder_enable,
-	.disable = px30_lvds_encoder_disable,
-	.atomic_check = rockchip_lvds_encoder_atomic_check,
+static const struct drm_encoder_funcs rockchip_lvds_encoder_funcs = {
+	.destroy = drm_encoder_cleanup,
 };
 
-static int rk3288_lvds_probe(struct platform_device *pdev,
-			     struct rockchip_lvds *lvds)
+static int rockchip_lvds_match_by_id(struct device *dev, const void *data)
 {
-	struct resource *res;
-	int ret;
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	lvds->regs = devm_ioremap_resource(lvds->dev, res);
-	if (IS_ERR(lvds->regs))
-		return PTR_ERR(lvds->regs);
-
-	lvds->pclk = devm_clk_get(lvds->dev, "pclk_lvds");
-	if (IS_ERR(lvds->pclk)) {
-		DRM_DEV_ERROR(lvds->dev, "could not get pclk_lvds\n");
-		return PTR_ERR(lvds->pclk);
-	}
-
-	lvds->pins = devm_kzalloc(lvds->dev, sizeof(*lvds->pins),
-				  GFP_KERNEL);
-	if (!lvds->pins)
-		return -ENOMEM;
-
-	lvds->pins->p = devm_pinctrl_get(lvds->dev);
-	if (IS_ERR(lvds->pins->p)) {
-		DRM_DEV_ERROR(lvds->dev, "no pinctrl handle\n");
-		devm_kfree(lvds->dev, lvds->pins);
-		lvds->pins = NULL;
-	} else {
-		lvds->pins->default_state =
-			pinctrl_lookup_state(lvds->pins->p, "lcdc");
-		if (IS_ERR(lvds->pins->default_state)) {
-			DRM_DEV_ERROR(lvds->dev, "no default pinctrl state\n");
-			devm_kfree(lvds->dev, lvds->pins);
-			lvds->pins = NULL;
-		}
-	}
-
-	ret = clk_prepare(lvds->pclk);
-	if (ret < 0) {
-		DRM_DEV_ERROR(lvds->dev, "failed to prepare pclk_lvds\n");
-		return ret;
-	}
+	struct rockchip_lvds *lvds = dev_get_drvdata(dev);
+	unsigned int *id = (unsigned int *)data;
 
-	return 0;
+	return lvds->id == *id;
 }
 
-static int px30_lvds_probe(struct platform_device *pdev,
-			   struct rockchip_lvds *lvds)
+static struct rockchip_lvds *rockchip_lvds_find_by_id(struct device_driver *drv,
+						      unsigned int id)
 {
-	int ret;
-
-	/* MSB */
-	ret =  regmap_update_bits(lvds->grf, PX30_LVDS_GRF_PD_VO_CON1,
-				  PX30_LVDS_MSBSEL(1),
-				  PX30_LVDS_MSBSEL(1));
-	if (ret)
-		return ret;
-
-	/* PHY */
-	lvds->dphy = devm_phy_get(&pdev->dev, "dphy");
-	if (IS_ERR(lvds->dphy))
-		return PTR_ERR(lvds->dphy);
-
-	ret = phy_init(lvds->dphy);
-	if (ret)
-		return ret;
+	struct device *dev;
 
-	ret = phy_set_mode(lvds->dphy, PHY_MODE_LVDS);
-	if (ret)
-		return ret;
+	dev = driver_find_device(drv, NULL, &id, rockchip_lvds_match_by_id);
+	if (!dev)
+		return NULL;
 
-	return phy_power_on(lvds->dphy);
+	return dev_get_drvdata(dev);
 }
 
-static const struct rockchip_lvds_soc_data rk3288_lvds_data = {
-	.probe = rk3288_lvds_probe,
-	.helper_funcs = &rk3288_lvds_encoder_helper_funcs,
-};
-
-static const struct rockchip_lvds_soc_data px30_lvds_data = {
-	.probe = px30_lvds_probe,
-	.helper_funcs = &px30_lvds_encoder_helper_funcs,
-};
-
-static const struct of_device_id rockchip_lvds_dt_ids[] = {
-	{
-		.compatible = "rockchip,rk3288-lvds",
-		.data = &rk3288_lvds_data
-	},
-	{
-		.compatible = "rockchip,px30-lvds",
-		.data = &px30_lvds_data
-	},
-	{}
-};
-MODULE_DEVICE_TABLE(of, rockchip_lvds_dt_ids);
-
 static int rockchip_lvds_bind(struct device *dev, struct device *master,
 			      void *data)
 {
 	struct rockchip_lvds *lvds = dev_get_drvdata(dev);
 	struct drm_device *drm_dev = data;
-	struct drm_encoder *encoder;
-	struct drm_connector *connector;
-	struct device_node *remote = NULL;
-	struct device_node  *port, *endpoint;
-	int ret = 0, child_count = 0;
-	const char *name;
-	u32 endpoint_id = 0;
-
-	lvds->drm_dev = drm_dev;
-	port = of_graph_get_port_by_id(dev->of_node, 1);
-	if (!port) {
-		DRM_DEV_ERROR(dev,
-			      "can't found port point, please init lvds panel port!\n");
-		return -EINVAL;
-	}
-	for_each_child_of_node(port, endpoint) {
-		child_count++;
-		of_property_read_u32(endpoint, "reg", &endpoint_id);
-		ret = drm_of_find_panel_or_bridge(dev->of_node, 1, endpoint_id,
-						  &lvds->panel, &lvds->bridge);
-		if (!ret) {
-			of_node_put(endpoint);
-			break;
-		}
-	}
-	if (!child_count) {
-		DRM_DEV_ERROR(dev, "lvds port does not have any children\n");
-		ret = -EINVAL;
-		goto err_put_port;
-	} else if (ret) {
-		DRM_DEV_ERROR(dev, "failed to find panel and bridge node\n");
-		ret = -EPROBE_DEFER;
-		goto err_put_port;
-	}
-	if (lvds->panel)
-		remote = lvds->panel->dev->of_node;
-	else
-		remote = lvds->bridge->of_node;
-	if (of_property_read_string(dev->of_node, "rockchip,output", &name))
-		/* default set it as output rgb */
-		lvds->output = DISPLAY_OUTPUT_RGB;
-	else
-		lvds->output = rockchip_lvds_name_to_output(name);
-
-	if (lvds->output < 0) {
-		DRM_DEV_ERROR(dev, "invalid output type [%s]\n", name);
-		ret = lvds->output;
-		goto err_put_remote;
-	}
+	struct drm_encoder *encoder = &lvds->encoder;
+	struct drm_connector *connector = &lvds->connector;
+	int ret;
 
-	if (of_property_read_string(remote, "data-mapping", &name))
-		/* default set it as format vesa 18 */
-		lvds->format = LVDS_VESA_18;
-	else
-		lvds->format = rockchip_lvds_name_to_format(name);
+	/*
+	 * dual channel lvds mode only need to register one connector.
+	 */
+	if (lvds->primary)
+		return 0;
 
-	if (lvds->format < 0) {
-		DRM_DEV_ERROR(dev, "invalid data-mapping format [%s]\n", name);
-		ret = lvds->format;
-		goto err_put_remote;
-	}
+	ret = drm_of_find_panel_or_bridge(dev->of_node, 1, -1,
+					  &lvds->panel, &lvds->bridge);
+	if (ret)
+		return ret;
 
-	encoder = &lvds->encoder;
-	encoder->possible_crtcs = drm_of_find_possible_crtcs(drm_dev,
-							     dev->of_node);
+	encoder->possible_crtcs = rockchip_drm_of_find_possible_crtcs(drm_dev,
+								      dev->of_node);
 
-	ret = drm_simple_encoder_init(drm_dev, encoder, DRM_MODE_ENCODER_LVDS);
+	ret = drm_encoder_init(drm_dev, encoder, &rockchip_lvds_encoder_funcs,
+			       DRM_MODE_ENCODER_LVDS, NULL);
 	if (ret < 0) {
-		DRM_DEV_ERROR(drm_dev->dev,
+		DRM_DEV_ERROR(lvds->dev,
 			      "failed to initialize encoder: %d\n", ret);
-		goto err_put_remote;
+		return ret;
 	}
 
-	drm_encoder_helper_add(encoder, lvds->soc_data->helper_funcs);
+	drm_encoder_helper_add(encoder, &rockchip_lvds_encoder_helper_funcs);
 
 	if (lvds->panel) {
-		connector = &lvds->connector;
-		connector->dpms = DRM_MODE_DPMS_OFF;
+		struct rockchip_drm_private *private = drm_dev->dev_private;
+
 		ret = drm_connector_init(drm_dev, connector,
 					 &rockchip_lvds_connector_funcs,
 					 DRM_MODE_CONNECTOR_LVDS);
